import { Minus, Plus, RefreshCcw } from"lucide-react";
import { useState } from"react"; 

import StatCircle from"@/components/atoms/StatCircle";
import { STAT_COLOR_MAP } from"@/constants/breedingConstants";
import { usePersistentState } from"@/utils/usePersistentState"; const NODE_SIZE = 48;
const BASE_PAIR_GAP = 40;
const BASE_ROW_GAP = 90;
const VERTICAL_GAP = 60; const getColors = (stats) => stats.map((stat) => STAT_COLOR_MAP[stat] ||"#ffffff"); function TreeScheme({ selectedIvCount, selectedIvStats, nature }) { const [activeIdsArray, setActiveIdsArray] = usePersistentState("breeding_activeNodes", [] ); const [zoomLevel, setZoomLevel] = useState(1); const activeIds = new Set(activeIdsArray); const updateActiveIds = (newSet) => { setActiveIdsArray(Array.from(newSet)); }; const generateTree = () => { const clampedCount = Math.min(selectedIvCount ?? 0, 6); const baseStats = selectedIvStats.slice(0, clampedCount); const stats = nature ? ["Nature", ...baseStats] : baseStats; if (stats.length === 0) return []; const levels = []; let currentLevel = [stats]; while (currentLevel.length > 0) { levels.push(currentLevel); const nextLevel = []; currentLevel.forEach((nodeStats) => { if (nodeStats.length > 1) { nextLevel.push(nodeStats.slice(0, -1), nodeStats.slice(1)); } }); currentLevel = nextLevel; } return levels .map((level) => level.map((nodeStats) => getColors(nodeStats))) .reverse(); }; const dataByRow = generateTree(); const totalRows = dataByRow.length; const handleNodeClick = (rowIndex, colIndex) => { const clickedId = `${rowIndex}-${colIndex}`; const newSet = new Set(activeIds); const isTurningOn = !newSet.has(clickedId); if (isTurningOn) { newSet.add(clickedId); const activateAncestors = (r, c) => { if (r === 0) return; const parentRow = r - 1; newSet.add(`${parentRow}-${c * 2}`); newSet.add(`${parentRow}-${c * 2 + 1}`); activateAncestors(parentRow, c * 2); activateAncestors(parentRow, c * 2 + 1); }; activateAncestors(rowIndex, colIndex); } else { newSet.delete(clickedId); const deactivateDescendants = (r, c) => { const childRow = r + 1; if (childRow >= totalRows) return; const childCol = Math.floor(c / 2); const childId = `${childRow}-${childCol}`; if (newSet.has(childId)) { newSet.delete(childId); deactivateDescendants(childRow, childCol); } }; deactivateDescendants(rowIndex, colIndex); const deactivateAncestors = (r, c) => { if (r === 0) return; const parentRow = r - 1; const leftP = `${parentRow}-${c * 2}`; const rightP = `${parentRow}-${c * 2 + 1}`; if (newSet.has(leftP)) { newSet.delete(leftP); deactivateAncestors(parentRow, c * 2); } if (newSet.has(rightP)) { newSet.delete(rightP); deactivateAncestors(parentRow, c * 2 + 1); } }; deactivateAncestors(rowIndex, colIndex); } updateActiveIds(newSet); }; const rowConfigs = Array.from({ length: totalRows }, () => ({ size: NODE_SIZE, pairGap: 0, rowGap: 0, })); if (rowConfigs.length > 0) { rowConfigs[0].pairGap = BASE_PAIR_GAP; rowConfigs[0].rowGap = BASE_ROW_GAP; } for (let i = 0; i < totalRows - 1; i++) { const current = rowConfigs[i]; const next = rowConfigs[i + 1]; const dist = 2 * current.size + current.pairGap + current.rowGap; const nextGap = dist - next.size; next.pairGap = nextGap; next.rowGap = nextGap; } return ( <div className="relative flex h-full w-full flex-col items-center"> {/* Legend / Key - Sticky inside the container */} <div className="sticky top-0 z-[20] flex w-full items-center justify-between border-b border-white/5 bg-[#1e2025]/95 px-6 py-4 shadow-md backdrop-blur-md"> <div className="flex flex-wrap gap-2"> {selectedIvStats.slice(0, selectedIvCount).map((statName, index) => ( <div key={index} className="flex items-center gap-2 rounded-full border border-white/10 bg-black/40 px-2.5 py-1" > <StatCircle ivColors={[STAT_COLOR_MAP[statName]]} size={12} className="shadow-none" /> <span className="text-[10px] font-bold tracking-wider uppercase"> {statName} </span> </div> ))} </div> {/* Zoom Controls */} <div className="ml-4 flex shrink-0 items-center gap-1 rounded-lg border border-white/10 bg-black/40 p-1"> <button onClick={() => setZoomLevel((z) => Math.max(z - 0.1, 0.3))} className="rounded p-1.5 transition-colors hover:bg-white/10 hover:" > <Minus size={16} /> </button> <span className="w-10 text-center font-mono text-xs"> {Math.round(zoomLevel * 100)}% </span> <button onClick={() => setZoomLevel((z) => Math.min(z + 0.1, 2.0))} className="rounded p-1.5 transition-colors hover:bg-white/10 hover:" > <Plus size={16} /> </button> <div className="mx-1 h-4 w-px bg-white/10" /> <button onClick={() => setZoomLevel(1)} className="rounded p-1.5 transition-colors hover:bg-white/10 hover:" title="Reset Zoom" > <RefreshCcw size={14} /> </button> </div> </div> {/* Scrollable Tree Area */} <div className="bg-opacity-5 relative w-full flex-1 overflow-auto bg-[url('/grid.svg')] p-8"> <div className="mx-auto min-w-max pt-10 pb-20"> <div className="flex origin-top flex-col items-center transition-transform duration-200 ease-out" style={{ gap: `${VERTICAL_GAP}px`, transform: `scale(${zoomLevel})`,"--node-size": `${NODE_SIZE}px`,"--vertical-gap": `${VERTICAL_GAP}px`, }} > {dataByRow.map((rowItems, rowIndex) => { const config = rowConfigs[rowIndex]; const isLastRow = rowIndex === totalRows - 1; return ( <div key={`row-${rowIndex}`} className="flex justify-center" style={{ gap: `${config.rowGap}px`, }} > {rowItems.reduce((pairs, colors, i) => { if (i % 2 === 0) { const next = rowItems[i + 1]; const id1 = `${rowIndex}-${i}`; const id2 = `${rowIndex}-${i + 1}`; pairs.push( <div className={`relative flex items-center justify-center ${ !isLastRow ?"before:absolute before:top-1/2 before:right-0 before:left-0 before:-z-10 before:mx-[calc(var(--node-size)/2)] before:h-[1px] before:bg-white/20 before:content-[''] after:absolute after:top-1/2 after:left-1/2 after:-z-10 after:h-[calc(var(--vertical-gap)+var(--node-size)/2+10px)] after:w-[1px] after:-translate-x-1/2 after:bg-white/20 after:content-['']" :"" } `} style={{ gap: `${config.pairGap}px` }} key={`${rowIndex}-pair-${i / 2}`} > <div className="relative z-[2] flex items-center justify-center"> <StatCircle ivColors={colors} onClick={() => handleNodeClick(rowIndex, i)} isActive={activeIds.has(id1)} isDimmed={ activeIds.size > 0 && !activeIds.has(id1) } /> </div> {next && ( <div className="relative z-[2] flex items-center justify-center"> <StatCircle ivColors={next} onClick={() => handleNodeClick(rowIndex, i + 1)} isActive={activeIds.has(id2)} isDimmed={ activeIds.size > 0 && !activeIds.has(id2) } /> </div> )} </div> ); } return pairs; }, [])} </div> ); })} </div> </div> </div> </div> );
} export default TreeScheme; 
